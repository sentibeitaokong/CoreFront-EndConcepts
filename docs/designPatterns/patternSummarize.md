# JavaScript 设计模式

## 1. 创建型模式 (Creational Patterns)
这类模式处理对象的**创建机制**，旨在将对象的创建与使用解耦，让代码在面对需求变化时更具弹性。

| 模式名称 | 核心定义 | 典型应用场景 |
| :--- | :--- | :--- |
| **单例模式 (Singleton)** | 确保一个类只有一个实例，并提供全局访问点。 | 全局 Store (Vuex/Redux)、登录弹窗、数据库连接池。 |
| **工厂模式 (Factory)** | 不暴露创建逻辑，通过一个共同的接口来创建对象。 | 弹窗组件库（根据类型创建 Success/Error 弹窗）。 |
| **构造器模式 (Constructor)**| 使用 `new` 关键字和 `constructor` 创建特定类型对象。 | 基础类定义、对象实例化。 |
| **原型模式 (Prototype)** | 通过克隆现有的对象来创建新对象，而不是重新实例化。 | JavaScript 自身的原型链继承机制。 |

## 2. 结构型模式 (Structural Patterns)
这类模式关注如何组合类和对象以形成**更大的结构**，类似于搭建积木。

| 模式名称 | 核心定义 | 典型应用场景 |
| :--- | :--- | :--- |
| **模块模式 (Module)** | 隐藏内部实现细节，只暴露公共接口。 | ES Modules (`export/import`)、IIFE (立即执行函数)。 |
| **装饰器模式 (Decorator)** | 在不改变原对象的基础上，动态给对象添加额外功能。 | 高阶组件 (HOC)、埋点统计、ES7 `@decorator` 语法。 |
| **代理模式 (Proxy)** | 为对象提供占位符或代理，以控制对它的访问。 | Vue 3 响应式原理、图片预加载、合并 HTTP 请求。 |
| **适配器模式 (Adapter)** | 将一个接口转换成客户希望的另一个接口。 | 兼容旧版 SDK 接口、格式化后端返回的不同数据结构。 |
| **组合模式 (Composite)** | 将对象组合成树形结构，以表示“部分-整体”层次。 | 文件夹/文件系统、DOM 树、UI 组件树。 |
| **享元模式 (Flyweight)** | 通过共享技术有效地支持大量细粒度的对象。 | **虚拟列表** (针对海量数据只渲染可视区域节点)。 |
| **外观模式 (Facade)** | 为子系统中的一组接口提供一个一致的高层界面。 | `jQuery` 的 `$(el).on()`（抹平了不同浏览器的事件监听差异）。 |

## 3. 行为型模式 (Behavioral Patterns)
这类模式专注于对象之间的**通信和职责分配**，是处理业务逻辑最复杂也最精彩的部分。

| 模式名称 | 核心定义 | 典型应用场景 |
| :--- | :--- | :--- |
| **观察者模式 (Observer)** | 对象间一对多的依赖，目标改变时通知所有观察者。 | **Vue 2 响应式原理**。 |
| **发布-订阅 (Pub-Sub)** | 通过调度中心进行通信，发布者和订阅者完全解耦。 | **Event Bus (事件总线)**、Node.js 的 `EventEmitter`。 |
| **策略模式 (Strategy)** | 定义一系列算法并封装，使其可以相互替换。 | **消除繁琐的 `if-else`**、表单校验规则、计费策略。 |
| **状态模式 (State)** | 允许对象在内部状态改变时改变其行为。 | 交通灯控制、复杂工作流审批、有限状态机 (FSM)。 |
| **命令模式 (Command)** | 将请求封装成对象，支持撤销、重做和排队。 | 文本编辑器操作、遥控器按钮、事务管理。 |
| **职责链模式 (Chain)** | 将请求沿着处理者链传递，直到被处理。 | **Express/Koa 中间件**、DOM 事件冒泡、多级审批。 |
| **迭代器模式 (Iterator)** | 提供一种方法顺序访问聚合对象，而不暴露内部表示。 | `for...of` 循环、`Symbol.iterator`、生成器。 |
| **模板方法 (Template)** | 在父类中定义算法骨架，将具体步骤延迟到子类。 | **生命周期钩子** (如 React `componentDidMount`)。 |
| **中介者模式 (Mediator)** | 通过中介对象封装交互，降低组件间的耦合。 | 机场塔台、**Vuex/Redux 的核心逻辑层**。 |


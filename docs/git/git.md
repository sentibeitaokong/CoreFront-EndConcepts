# Git 常用命令速查手册

本文档整理了 Git 的常用命令，按照功能进行分类，方便快速查阅。

## 1. 仓库设置与初始化

| 命令 | 详细说明 |
| :--- | :--- |
| `git init` | 在当前目录中创建一个新的 Git 仓库。 |
| `git config --global credential.helper cache` | 设置凭证缓存，避免每次推送都输入密码。 |

## 2. 日常工作流程

### 2.1 状态检查与差异比较

| 命令 | 详细说明 |
| :--- | :--- |
| `git status` | 检查当前工作目录和暂存区的状态（查看未跟踪、已修改、已暂存的文件）。 |
| `git diff` | 查看**工作目录**中已修改但**尚未暂存**的文件与上次提交的差异。 |
| `git diff --cached` | 查看**暂存区**中的文件与**上次提交**的差异。 |
| `git diff --word-diff` | 在单词（Word）层面而不是行（Line）层面显示差异。 |

### 2.2 暂存与提交

| 命令 | 详细说明 |
| :--- | :--- |
| `git add <file>` | 将指定文件的更改添加到暂存区（Stage）。 |
| `git add .` | 将当前目录下所有已修改和新建的文件添加到暂存区。 |
| `git commit` | 将暂存区的所有内容创建一个新的提交（会打开文本编辑器输入提交信息）。 |
| `git commit -m "message"` | 提交并直接附上提交说明信息。 |
| `git commit -a -m "message"` | 跳过 `git add` 步骤，直接将所有**已跟踪**文件的修改暂存并提交。 |

### 2.3 文件操作

| 命令 | 详细说明 |
| :--- | :--- |
| `git rm <file>` | 从工作目录和暂存区中删除文件。 |
| `git rm -f <file>` | 强制删除（当文件在暂存区有修改时使用）。 |
| `git rm --cached <file>` | 仅从暂存区和版本库中删除，但保留工作目录中的文件（用于“反追踪”）。 |
| `git mv <old-name> <new-name>` | 重命名文件或移动文件。 |

## 3. 查看历史与撤销操作

### 3.1 查看提交历史 (`git log`)

| 命令 | 详细说明 |
| :--- | :--- |
| `git log` | 显示完整的提交历史记录。 |
| `git log -p -2` | 显示最近 2 次提交的详细差异（diff）。 |
| `git log --stat` | 显示简要的增改行数统计。 |
| `git log --pretty=oneline` | 将每个提交压缩到一行显示。 |
| `git log --pretty=format:"%h - %an, %ar : %s"` | 自定义格式化输出。 |
| `git log --since=2.weeks` | 仅显示最近两周内的提交。 |
| `git log --author="nick"` | 仅显示指定作者的提交。 |
| `git log --grep="first commit"` | 搜索提交信息中包含指定字符串的提交。 |
| `git log --author="nick" --grep="first" --all-match` | 同时满足多个筛选条件（`--all-match` 表示 AND 关系）。 |
| `git reflog` | 查看所有分支的所有操作记录，包括已被删除的 commit 和 reset 操作（用于“后悔药”）。 |

### 3.2 撤销与重置

| 命令 | 详细说明 |
| :--- | :--- |
| `git commit --amend` | 修改**最后一次**提交（可以修改提交信息或追加文件）。 |
| `git reset HEAD <file>` | 将文件从**暂存区**撤销，但保留工作目录中的修改（`git add` 的反操作）。 |
| `git restore --staged <file>` | 同上，新版 Git 推荐用法。 |
| `git checkout -- <file>` | **丢弃**工作目录中对文件的修改，恢复到最近一次提交的状态。 |
| `git restore <file>` | 同上，新版 Git 推荐用法。**此操作会丢失修改！** |
| `git reset --soft HEAD^` | 撤销上一次 `commit`，但保留暂存区和工作目录的更改。 |
| `git reset --mixed HEAD^` | **(默认)** 撤销上一次 `commit`，保留工作目录的更改，但清空暂存区。 |
| `git reset --hard HEAD^` | **(危险)** 彻底撤销上一次 `commit`，暂存区和工作目录都将回滚。 |

## 4. 远程仓库操作

| 命令 | 详细说明 |
| :--- | :--- |
| `git remote -v` | 查看已配置的远程仓库及其 URL。 |
| `git remote add <name> <url>` | 添加一个新的远程仓库。 |
| `git remote show <name>` | 查看指定远程仓库的详细信息。 |
| `git remote rename <old> <new>` | 重命名远程仓库。 |
| `git remote rm <name>` | 删除指定的远程仓库。 |
| `git fetch <remote> <branch>` | 从远程仓库抓取更新，但**不**自动合并到本地分支。 |
| `git pull <remote> <branch>` | 从远程仓库抓取更新并**自动合并**到当前本地分支 (`fetch` + `merge`)。 |
| `git push <remote> <branch>` | 将本地分支的提交推送到远程仓库。 |
| `git push origin --delete <branch>` | 删除一个远程分支。 |
| `git fetch --all && git reset --hard origin/master && git pull` | **(危险)** 强制用远程分支覆盖本地分支。 |

## 5. 分支管理

### 5.1 本地分支

| 命令 | 详细说明 |
| :--- | :--- |
| `git branch <name>` | 创建一个新分支。 |
| `git branch` | 列出所有本地分支。 |
| `git branch -v` | 查看各分支的最后一个提交信息。 |
| `git checkout <name>` | 切换到指定分支。 |
| `git checkout -b <name>` | 创建并立即切换到新分支。 |
| `git branch -d <name>` | 删除一个**已合并**的分支。 |
| `git branch -D <name>` | **强制**删除一个分支（无论是否已合并）。 |
| `git branch --merged` | 查看哪些分支已被合并到当前分支。 |
| `git branch --no-merged` | 查看哪些分支尚未被合并到当前分支。 |

### 5.2 跟踪分支

| 命令 | 详细说明 |
| :--- | :--- |
| `git checkout --track origin/serverfix` | 创建并跟踪一个远程分支（本地分支名与远程同名）。 |
| `git checkout -b sf origin/serverfix` | 创建本地分支 `sf` 并跟踪远程分支 `origin/serverfix`。 |
| `git branch -u origin/serverfix` | 为当前分支设置上游（跟踪）分支。 |
| `git branch --set-upstream-to=origin/serverfix` | 同上。 |
| `git branch -vv` | 查看本地分支与所跟踪的远程分支的关联状态。 |

### 5.3 变基 (`rebase`)

| 命令 | 详细说明 |
| :--- | :--- |
| `git rebase <basebranch>` | 将当前分支的提交“变基”到 `<basebranch>` 的顶端，使历史记录更线性。 |
| `git rebase <base> <topic>` | 将 `<topic>` 分支变基到 `<base>` 分支上。 |

## 6. 标签管理 (`tag`)

| 命令 | 详细说明 |
| :--- | :--- |
| `git tag` | 列出所有标签。 |
| `git tag -l 'v1.4.2.*'` | 使用通配符搜索标签。 |
| `git tag -a v1.4 -m "message"` | 创建一个带附注的标签（推荐）。 |
| `git tag -s v1.5 -m "message"` | 创建一个 GPG 签名的标签。 |
| `git tag -v <tag-name>` | 验证一个 GPG 签名标签。 |
| `git show <tag-name>` | 查看标签信息和对应的提交信息。 |
| `git tag -a v1.2 <commit-hash>` | 对过去的某个提交追加标签。 |
| `git push origin <tag-name>` | 将指定标签推送到远程仓库。 |
| `git push origin --tags` | 将所有本地新增的标签一次性推送到远程仓库。 |

## 7. 高级工具

### 7.1 贮藏 (`stash`)

| 命令 | 详细说明 |
| :--- | :--- |
| `git stash` | 将工作目录中未提交的修改（已跟踪文件）临时保存起来。 |
| `git stash list` | 查看所有贮藏记录。 |
| `git stash apply stash@{2}` | 应用指定的贮藏，但**不**从列表中移除。 |
| `git stash pop` | 应用最近的贮藏，并从列表中**移除**。 |
| `git stash drop stash@{2}` | 丢弃指定的贮藏。 |
| `git stash -u` 或 `--include-untracked` | 贮藏时同时包含未跟踪的文件。 |
| `git stash -a` 或 `--all` | 贮藏时同时包含所有文件（包括忽略的文件）。 |
| `git stash branch <new-branch>` | 基于指定的贮藏创建一个新分支。 |

### 7.2 清理 (`clean`)

| 命令 | 详细说明 |
| :--- | :--- |
| `git clean -n` | **演习**：显示将要被移除的未跟踪文件。 |
| `git clean -f` | **(危险)** 强制移除工作目录中所有未跟踪的文件。 |
| `git clean -f -d` | **(危险)** 同时移除未跟踪的文件和空目录。 |

### 7.3 改写历史 (`filter-branch` / `filter-repo`)

| 命令 | 详细说明 |
| :--- | :--- |
| `git filter-branch --tree-filter 'cmd'` | **(已过时)** 对每个提交执行指定命令来改写历史。 |
| `git filter-repo` | **(推荐)** 新一代工具，用于批量改写历史，更安全、更快速。 |
| `git filter-branch --tree-filter 'rm -f passwords.txt' HEAD` | 示例：从所有提交中移除 `passwords.txt` 文件。 |

### 7.4 其他

| 命令 | 详细说明 |
| :--- | :--- |
| `.gitignore` | 文件，用于指定 Git 应该忽略的文件或目录模式（如 `*.log`, `/node_modules`）。 |

![Logo](/gitFirst.png)
![Logo](/gitSecond.png)

## 8. 应用场景

### 8.1 初始化一个新项目 🚀

当你开始一个全新的项目，并希望使用 Git 来管理其版本时。

| 命令 | 详细说明 |
| :--- | :--- |
| **`git init`** | 在当前项目文件夹中创建一个新的 Git 仓库。这会生成一个隐藏的 `.git` 目录，它包含了仓库所有必要的文件和元数据。 |
| **`git add <file>`** | 将文件的当前版本添加到“暂存区”（Staging Area）。暂存区像是一个快照的草稿箱，你可以把这次想提交的全部修改都放进去。使用 `git add .` 可以暂存所有已修改和新建的文件。 |
| **`git commit -m "提交信息"`** | 将暂存区的所有内容创建成一个新的“提交”（Commit），并永久保存在你的本地仓库历史中。提交信息应当清晰地描述这次提交所做的更改。 |
| **`git status`** | 这是你最常使用的命令之一。它会显示你的工作目录和暂存区的状态，告诉你哪些文件被修改了、哪些文件还未被 Git 追踪、哪些文件已暂存等。 |

**应用流程：**

1.  在你的项目根目录运行 `git init`。
2.  编写代码，创建文件。
3.  运行 `git status` 查看文件状态，它们会显示为 "untracked files"（未追踪的文件）。
4.  使用 `git add <文件名>` 或 `git add .` 将你的新文件和修改添加到暂存区。
5.  再次运行 `git status`，文件会显示为 "changes to be committed"（待提交的更改）。
6.  使用 `git commit -m "Initial commit"` 提交你的第一个版本。

### 8.2 进行日常开发（分支、修改、提交） 🌿

在项目中开发新功能或修复 Bug 时，最佳实践是使用“分支”（Branch）来隔离你的工作，以免影响主线（`main` 或 `master`）。

| 命令 | 详细说明 |
| :--- | :--- |
| **`git branch`** | 不带参数时，列出所有本地分支，并用 `*` 标记出你当前所在的分支。 |
| **`git branch <分支名>`** | 创建一个新分支，但不会自动切换过去。 |
| **`git checkout <分支名>`** | 切换到指定的分支。你的工作目录中的文件会自动更新为该分支最后一次提交时的状态。 |
| **`git checkout -b <分支名>`** | 这是一个常用组合，它会 **创建** 一个新分支并 **立即切换** 过去。相当于 `git branch <分支名>` + `git checkout <分支名>`。 |
| **`git merge <分支名>`** | 将指定分支的历史合并到你当前所在的分支。例如，在 `main` 分支上运行 `git merge feature-x` 会将 `feature-x` 分支上的所有提交合并到 `main` 分支。 |
| **`git branch -d <分支名>`** | 删除一个已经合并过的分支。如果分支还没合并，Git 会提示你，你可以使用 `-D` (大写) 来强制删除。 |

**应用流程：**

1.  假设你要开发一个“用户登录”功能，首先从 `main` 分支创建并切换到一个新分支：`git checkout -b feature-login`。
2.  在这个 `feature-login` 分支上，进行代码编写、修改文件。
3.  像场景一那样，周期性地使用 `git add .` 和 `git commit -m "Added login form"` 来保存你的进度。
4.  功能开发完毕后，切回主分支：`git checkout main`。
5.  将你的功能分支合并到主分支：`git merge feature-login`。
6.  合并成功后，可以删除不再需要的功能分支：`git branch -d feature-login`。

### 8.3 与团队协作（远程仓库） 🤝

当多人共同开发一个项目时，就需要一个中央仓库（如 GitHub, GitLab）来同步彼此的工作。

| 命令 | 详细说明 |
| :--- | :--- |
| **`git clone <仓库URL>`** | 从远程服务器下载一个项目的完整拷贝，包括所有历史记录。这是你加入一个现有项目时的第一步。 |
| **`git remote -v`** | 查看你配置的远程仓库地址。`origin` 是 `git clone` 时为你创建的默认远程仓库名。 |
| **`git pull`** | 从远程仓库 **拉取** 最新的更改并自动与你当前的分支 **合并**。这是保持本地代码同步的常用方法。它相当于 `git fetch` + `git merge`。 |
| **`git fetch`** | 仅从远程仓库 **拉取** 最新的更改，但 **不** 会自动合并。这让你可以在合并前先查看远程的变动。 |
| **`git push`** | 将你本地的提交 **推送** 到远程仓库，与团队分享你的工作。 |
| **`git push -u origin <分支名>`** | 当你第一次推送一个新创建的本地分支时，使用 `-u` 参数可以将其与远程的同名分支关联起来。之后你在这个分支上只需运行 `git push` 即可。 |

**应用流程：**

1.  **开始工作前**：运行 `git pull`，确保你的本地 `main` 分支是最新版本。
2.  **开发新功能**：按照场景二，创建 `feature-x` 分支并进行开发和提交。
3.  **分享你的分支**：运行 `git push -u origin feature-x`，将你的功能分支推送到远程，这样其他人也能看到你的进度或进行代码审查。
4.  **功能完成并合并到 main 后**：在本地 `main` 分支上，运行 `git push`，将合并后的 `main` 分支推送到远程，更新项目主线。

### 8.4 查看历史与撤销操作 ⏪

有时候你需要查看过去的提交记录，或者撤销一些不满意的修改。

| 命令 | 详细说明 |
| :--- | :--- |
| **`git log`** | 显示从最新到最旧的提交历史。每个提交都包含作者、日期、提交信息和唯一的 SHA-1 哈希值。 |
| **`git log --oneline --graph`** | `log` 命令有很多强大的参数。`--oneline` 会将每个提交压缩为一行显示；`--graph` 会用 ASCII 图形展示分支的合并历史。 |
| **`git diff`** | 查看 **尚未暂存** 的文件修改内容。 |
| **`git diff --staged`** | 查看 **已经暂存但尚未提交** 的文件修改内容。 |
| **`git reset <文件>`** | 将文件从暂存区 **移出**，但保留工作目录中的修改。用于撤销 `git add`。 |
| **`git checkout -- <文件>`** | **彻底丢弃** 工作目录中对某个文件的修改，将其恢复到最近一次提交时的状态。**这是一个危险操作，修改会丢失！** |
| **`git revert <提交哈希>`** | 创建一个新的提交，内容与指定的旧提交 **完全相反**，从而“撤销”该次提交的效果。这是在公共历史中安全撤销更改的首选方式。 |

**应用流程：**

*   **"我 add 错文件了！"**：运行 `git reset <文件名>`。
*   **"我把这个文件改乱了，想回到最初的版本！"**：运行 `git checkout -- <文件名>`。
*   **"这个功能上线后发现有 Bug，需要紧急撤销！"**：找到引入 Bug 的那个提交的哈希值（通过 `git log`），然后运行 `git revert <提交哈希>`，再 `git push`。

### 8.5 解决冲突

**冲突是如何产生的？**

1.  你和你的同事都修改了同一个文件 `style.css` 的第 10 行。
2.  你的同事先将他的修改推送到了 `main` 分支。
3.  你尝试 `git pull` 或 `git merge main` 来更新你的代码，此时冲突就发生了。


**解决冲突的详细步骤**

假设你当前在 `feature` 分支，想要合并 `main` 分支的更新，运行 `git merge main` 后，终端提示冲突。

| 步骤 | 命令 | 详细说明 |
| :--- | :--- | :--- |
| **1. 识别冲突文件** | `git status` | 终端会明确告诉你合并失败。运行 `git status`，你会看到一个名为 “Unmerged paths”（未合并的路径）的列表，这里列出了所有包含冲突的文件。 |
| **2. 打开冲突文件** | (使用你的代码编辑器) | 打开任何一个冲突的文件，你会看到类似下面的特殊标记，它们将不同分支的修改包裹了起来。 |
| **3. 手动解决冲突** | (编辑文件) | 这是核心步骤。你需要**手动编辑文件**，删除 Git 添加的特殊标记，并决定最终要保留的代码。 |
| **4. 标记为已解决** | `git add <文件名>` | 在你确认一个文件已经修改完毕、冲突已解决后，使用 `git add` 命令来告诉 Git：“这个文件我已经处理好了。” |
| **5. 完成合并** | `git commit` | 当所有冲突文件都通过 `git add` 标记为已解决后，运行 `git commit`。Git 会自动生成一个合并提交信息，你只需保存并关闭编辑器即可完成整个合并过程。 |

**如何编辑冲突文件**
当你打开冲突文件时，会看到：

```
<<<<<<< HEAD
// 这是你当前分支（HEAD）所做的修改
const color = "blue";
=======
// 这是你正在合并进来的那个分支所做的修改
const color = "red";
>>>>>>> main
```

*   `<<<<<<< HEAD` 到 `=======` 之间的内容，是你**当前所在分支**的修改。
*   `=======` 到 `>>>>>>> <分支名>` 之间的内容，是你**要合并进来的那个分支**的修改。

**你有以下几种选择来解决它：**

1.  **保留你的修改**：删除 `=======` 到 `>>>>>>> main` 的所有内容，并删掉标记。
    ```js
    // 决定保留蓝色
    const color = "blue";
    ```
2.  **接受别人的修改**：删除 `<<<<<<< HEAD` 到 `=======` 的所有内容，并删掉标记。
    ```js
    // 决定接受红色
    const color = "red";
    ```
3.  **保留双方的修改**：根据需要，同时保留两部分代码。
    ```js
    // 决定两个颜色都保留
    const primaryColor = "blue";
    const alertColor = "red";
    ```
4.  **进行全新的修改**：删除所有标记，并写入全新的、你认为最合适的代码。
    ```js
    // 决定使用一个全新的颜色
    const themeColor = "purple";
    ```
**关键在于：** 最终的文件内容必须是你期望的样子，并且**所有** `<<<<<<<`, `=======`, `>>>>>>>` 标记都必须被删除。

**使用图形化工具解决冲突**

对于新手来说，使用 VS Code 或其他 IDE 内置的工具会让解决冲突变得非常直观。
当 VS Code 检测到冲突时，它会在冲突代码块的上方提供几个可点击的选项：

*   **`Accept Current Change`** (接受当前更改)：只保留 `HEAD` 的版本。
*   **`Accept Incoming Change`** (接受传入的更改)：只保留另一个分支的版本。
*   **`Accept Both Changes`** (接受双方的更改)：同时保留两者。
*   **`Compare Changes`** (比较更改)：并排高亮显示差异。
点击这些选项，IDE 会自动为你修改文件，大大降低了手动编辑出错的概率。

**“救命！我把冲突搞得一团糟！”——如何中止合并**

如果你在解决冲突的过程中感到困惑，或者不确定自己是否改对了，最好的办法就是**中止合并**，让仓库回到合并之前的状态。

| 场景 | 命令 | 效果 |
| :--- | :--- | :--- |
| 在 `git merge` 过程中 | `git merge --abort` | 取消本次合并，你的工作目录会恢复到运行 `merge` 命令之前的状态。 |
| 在 `git rebase` 过程中 | `git rebase --abort` | 取消本次变基，分支会回到变基之前的状态。 |

这个命令非常安全，是你解决冲突时的“后悔药”。


**预防冲突的最佳实践**

虽然学会解决冲突很重要，但更好的方式是尽量避免它。

1.  **频繁更新**：在开始一项新功能前，或在开发过程中，经常从主分支（如 `main`）`git pull` 或 `git rebase`，保持你的分支与主线同步。分歧越小，冲突的概率越低。
2.  **小步提交**：保持你的提交小而专注。一个提交只做一件事。这样即使有冲突，范围也会很小，容易解决。
3.  **有效沟通**：与你的团队成员沟通，了解彼此正在修改的模块，避免同时修改同一块核心代码。
4.  **使用功能分支**：严格遵守一人一分支的原则，不要直接在 `main` 或 `develop` 这种公共分支上直接开发。


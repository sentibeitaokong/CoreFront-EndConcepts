# JavaScript相等运算符

在 JavaScript 中，比较两个值是否“相等”比看起来要复杂，因为存在两种主要的比较方式：**严格相等**和**宽松相等**。理解它们的区别是编写健壮、无歧义代码的关键。

## 1. 严格相等运算符 (`===` 和 `!==`)

这是**推荐使用**的比较方式。它的规则简单、可预测。

### 1.1 工作原理

**不进行类型转换**，直接比较。如果两个值的类型和值都相同，则结果为 `true`。

1.  **类型不同？** -> `false`
2.  **类型相同？** -> 比较值。
    *   **原始类型** (`Number`, `String`, `Boolean`等): 比较它们的值是否相同。
    *   **引用类型** (`Object`, `Array`等): 比较它们是否指向内存中的**同一个对象**（即比较内存地址）。
    *   **特殊情况**:
        *   `NaN === NaN` -> `false` (NaN 不与任何值相等，包括它自己)
        *   `+0 === -0` -> `true`

### 1.2 示例

| 表达式 | 结果 | 原因 |
| :--- | :--- | :--- |
| `77 === "77"` | `false` | 类型不同 (Number vs String)。 |
| `true === 1` | `false` | 类型不同 (Boolean vs Number)。 |
| `null === undefined` | `false` | 类型不同。 |
| `const a = {}; const b = {}; a === b` | `false` | `a` 和 `b` 是两个不同的对象，内存地址不同。 |
| `const a = {}; const b = a; a === b` | `true` | `a` 和 `b` 指向同一个内存地址。 |
| `NaN === NaN` | `false` | `NaN` 的特殊规则。 |

> **✅ 黄金法则：** 在你的代码中，**始终默认使用 `===`**。它能避免大量由类型转换带来的意外行为。


## 2. 宽松相等运算符 (`==` 和 `!=`)

这是 JavaScript 中一个复杂且容易出错的部分。它在比较之前会尝试**转换值的类型**。

### 2.1  工作原理

`a == b` 的比较会经过一个复杂的**抽象相等比较算法**，主要规则如下：

1.  **类型相同？** -> 行为与 `===` 相同。
2.  **`null == undefined`？** -> `true` (这是唯一的特例)。
3.  **`Number == String`？** -> 将 `String` 转换为 `Number` 再比较。
4.  **`Boolean == 任何类型`？** -> 将 `Boolean` 转换为 `Number` (`true` -> `1`, `false` -> `0`) 再比较。
5.  **`Object == (String | Number | Symbol)`？** -> 将 `Object` 转换为原始类型（会调用内部的 ToPrimitive 操作。这个操作会根据上下文决定优先调用 `valueOf()` 还是 `toString()`方法`）再比较。

![Logo](/equal.png)

### 2.2 示例

| 表达式                 | 结果      | 转换过程                                            |
|:--------------------|:--------|:------------------------------------------------|
| `77 == "77"`        | `true`  | `"77"` -> `77`                                  |
| `true == 1`         | `true`  | `true` -> `1`                                   |
| `false == 0`        | `true`  | `false` -> `0`                                  |
| `"" == 0`           | `true`  | `""` -> `0`                                     |
| `"\n " == 0`        | `true`  | `"\n "` -> `""` -> `0`                          |
| `[1] == 1`          | `true`  | `[1]` -> `"1"` -> `1`                           |
| `[] == 0`           | `true`  | `[]` -> `""` -> `0`                             |
| `[] == false`       | `true`  | `[]` -> `""` -> `0`; `false` -> `0`             |
| `null == undefined` | `true`  | `规范中的特例。`                                       |
| `[]==![]`           | `true`  | `[]` -> `""` -> `0`;`![]`->`false` -> `0`       |
| `[]==[]`            | `false` | `两个数组的内存地址不同`                                   |
| `{}=={}`            | `false` | `两个对象的内存地址不同`                                   |
| `{}==!{}`           | `false` | `{}`->`'[object object]'`->`NaN`;`!{}`->`false` |

> **❌ 为什么应避免使用 `==`：** 它的类型转换规则复杂、不直观，是许多常见 bug 的根源。你很难记住所有的转换规则，这使得代码的行为难以预测。


## 3. 同值相等 (`Object.is()`)

`Object.is()` 是 ES6 引入的，用于判断两个值是否为“相同的值”。它被认为是比 `===` 更精确的比较方式。

### 3.1 工作原理

`Object.is()` 的行为与 `===` 基本完全相同，**除了两个特例**：

1.  `Object.is(NaN, NaN)` -> `true` (与 `===` 不同)
2.  `Object.is(+0, -0)` -> `false` (与 `===` 不同)

```js
object.is=function(a,b){
    // 情况 1: 处理 +0 和 -0
    // 如果 x 和 y 都是 0，它们通过 `===` 比较会是 true。
    // 但我们需要区分 +0 和 -0。
    // 技巧：1 / +0 === Infinity，而 1 / -0 === -Infinity。
    // 所以，如果它们的倒数不相等，说明一个是 +0，另一个是 -0。
    if (x === 0 && y === 0) {
        return 1 / x === 1 / y;
    }

    // 情况 2: 处理 NaN
    // NaN 是唯一一个不等于自身的值 (NaN !== NaN)。
    // 所以，如果 x 不等于 x，那么 x 就是 NaN。
    // 如果 x 和 y 都是 NaN，那么它们应该被认为是相等的。
    if (x !== x) {
        return y !== y;
    }

    // 情况 3: 其他所有情况
    // 对于所有其他值 (包括 null, undefined, string, boolean, object引用等)，
    // Object.is() 的行为与 === 完全相同。
    return x === y;
}
```

### 3.2 示例

| 表达式 | 结果 |
| :--- | :--- |
| `Object.is(77, "77")` | `false` |
| `Object.is({}, {})` | `false` |
| `Object.is(NaN, NaN)` | `true` |
| `Object.is(+0, -0)` | `false` |

> **用途：** `Object.is()` 在某些需要精确区分 `NaN` 或 `+0` 和 `-0` 的数学计算或算法场景中非常有用。在日常的业务逻辑中，`===` 依然是首选。

## 4. 常见问题与陷阱

以下是开发者（尤其是初学者）最容易踩的坑，它们几乎都与 `==` 的隐式类型转换有关。

#### 问题 1：`true`、`false` 与数字的比较

**现象**:
`if (myVar == true)` 这样的代码可能不会按预期工作。

**代码示例**:
```javascript
const value = "1";

if (value == true) { // "1" == true -> "1" == 1 -> 1 == 1 -> true
    console.log("Value is true"); // ✅ 执行
}

const text = "hello";
if (text == true) { // "hello" == true -> NaN == 1 -> false
    console.log("Text is true"); // ❌ 不执行
}
```

**✅ 解决方案**:
永远不要用 `== true` 或 `== false` 来检查真值。直接利用值的“真值性” (truthiness)。

```javascript
// 正确的方式
if (value) { 
    console.log("Value is truthy");
}
```

#### 问题 2：空数组与 `false` 的比较

**现象**:
`[]` 本身是一个“真值” (truthy)，但 `[] == false` 的结果却是 `true`。

**代码示例**:
```javascript
if ([]) {
    console.log("Empty array is truthy"); // ✅ 执行
}

console.log([] == false); // true
```

**原因 (逐步转换)**:
1.  `[] == false`
2.  `[]` 是对象，`false` 是布尔值。
3.  `false` 转换为数字 `0` -> `[] == 0`
4.  `[]` 尝试转换为原始类型，调用 `toString()` -> `"" == 0`
5.  `""` 字符串转换为空数字 `0` -> `0 == 0`
6.  结果为 `true`。

**✅ 解决方案**:
使用 `===`，或者通过 `array.length` 来判断数组是否为空。

#### 问题 3：`null` 与 `0` 的比较

**现象**:
`null == 0` 是 `false`，但 `null > 0` 和 `null >= 0` 却表现不一。

**代码示例**:
```javascript
console.log(null == 0); // false (宽松相等有 null 和 undefined 的特例)

console.log(null > 0);  // false (关系比较中，null -> 0)
console.log(null >= 0); // true (关系比较中，null -> 0)
```

**✅ 解决方案**:
同样，使用 `===` 进行显式检查，避免依赖 `null` 的隐式转换。

```javascript
const value = null;

if (value === 0) {
    // ...
}
if (value === null) {
    // ...
}
```

## 5. 总结与最终建议

| 运算符 | 描述 | 类型转换 | 适合场景 |
| :--- | :--- | :--- | :--- |
| **`===`** | **严格相等** | **否** | **99% 的情况。** 你的默认选择。 |
| **`==`** | **宽松相等** | **是** | 几乎从不。唯一的例外可能是 `val == null` (等价于 `val === null || val === undefined`)，但显式检查更清晰。 |
| **`Object.is()`** | **同值相等** | **否** | 需要精确区分 `NaN` 或 `+0` / `-0` 的特殊情况。 |

**最终建议：** 养成只使用 `===` 的习惯，你会为自己省去无数调试的时间，并写出更可预测、更可靠的代码。